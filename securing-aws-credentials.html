<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Securing AWS Credentials</title><link rel="stylesheet" href="././css/main.css"><link href="https://www.qrk.us/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="hella labs Atom Feed"></head><body id="index" class="home"><header id="banner" class="body"><h1><a href="./">hella labs </a></h1><nav><ul><li><a href="./pages/about.html">About</a></li><li><a href="./pages/projects.html">Projects</a></li><li class="active"><a href="./category/tech.html">Tech</a></li></ul></nav></header><section id="content" class="body"><article><header><h1 class="entry-title"><a href="./securing-aws-credentials.html" rel="bookmark" title="Permalink to Securing AWS Credentials">Securing AWS Credentials</a></h1></header><div class="entry-content"><footer class="post-info"><abbr class="published" title="2023-09-24T15:36:04.979187-04:00"> Published: Sun 24 September 2023 </abbr><br><abbr class="modified" title="2023-09-24T15:36:04.979187-04:00"> Updated: Sun 24 September 2023 </abbr><address class="vcard author"> By <a class="url fn" href="./author/ken.html">Ken</a></address><p>tags: <a href="./tag/aws.html">aws</a> <a href="./tag/sysadmin.html">sysadmin</a> <a href="./tag/identity.html">identity</a> <a href="./tag/encryption.html">encryption</a> </p></footer> <p>A single <a href="https://github.com/joho/aws-pony">rogue npm module</a>, Ruby gem, PyPi module, or ill-fated cURL command could expose you (and your employer) to extreme risk.</p><div class="toc"><span class="toctitle">Table of contents:</span><ul><li><a href="#is-this-you">Is this you?</a><ul><li><a href="#the-problem">The Problem</a></li><li><a href="#a-solution">A Solution</a></li><li><a href="#do-it-yourself">Do it Yourself</a></li></ul></li><li><a href="#shortcuts">Shortcuts</a><ul><li><a href="#enable-privileges">Enable Privileges</a></li><li><a href="#disable-privileges">Disable Privileges</a></li><li><a href="#assume-role">Assume Role</a></li></ul></li><li><a href="#related">Related</a></li></ul></div><h2 id="is-this-you">Is this you?</h2><div class="highlight"><pre><span></span><code><span class="c1"># ~/.aws/credentials</span>
<span class="k">[default]</span>
<span class="na">aws_access_key_id</span><span class="o">=</span><span class="s">AKIAIH7UMBRMK5L7GT2Q</span>
<span class="na">aws_secret_access_key</span><span class="o">=</span><span class="s">kyLQmrtPwdXrXdxiAOjS1v0zrR06CiEzKKWXIRum</span>
</code></pre></div><p></p><p>If you have this file it is probably so that you can use the credentials with awscli or another command-line utility, or so that you can test a native build of your application that calls AWS in an IDE or when invoked by a build tool such as Maven. We'll explore a specific case as representative of a broad class of vulnerabilities, specifically how a sensitive file could be stolen and how you can make that prohibitively difficult.</p><h3 id="the-problem">The Problem</h3><p>You are vulnerable to the theft and misuse of your AWS identity if:</p><ol><li>you lose your non-encrypted computer disk where the file is stored, or</li><li>a malicious process designed to steal this credential runs on your computer.</li></ol><p>This attack is not unique to AWS, of course. Many development and systems administration tools follow the same pattern of issuing an API token as a primary trust factor. Proper handling of these token is too often an afterthought, and we can only surmise that the implications of that carelessness are truly not appreciated by a significant number of software developers. <a href="https://www.cyberscoop.com/twilio-api-eavesdropper-vulnerability/">The discovery that hundreds of mobile apps had hard-coded API keys for the Twilio platform</a> is evidence of the same.</p><p>Suppose your employer requires full-disk encryption for all company-provided equipment. In that case a loss of custody of your portable development machine; while inconvenient and frustrating and definitely a security incident; is not a situation worsened by the further implications of a data leak or identity theft. Even with that considerable degree of protection in place, there is another constellation of attack vectors not at all mitigated by full-disk encryption. How many times have your downloaded a utility or app directly from the author or vendor by pasting a <code>curl</code> or <code>wget</code> command into your terminal or downloaded an executable or package file? In every case this action implies the delegation of your own privileges on that computer to whomever authored the code that you just executed.</p><p>Your computer doesn't know the difference between you and your logged-in user, and it's that user that owns all of your files and runs all of your processes. That user mostly runs programs written by people other than you. Those programs, running as your user, could read and upload your AWS credentials or any other file for that matter if the source code were maliciously modified to do so. There would be no barrier to that malicious code reading the file, initiating the egressing network connection, nor any tell.</p><p>Importantly, it is possible to dramatically reduce the scope of code that you actually trust in order to operate normally.</p><h3 id="a-solution">A Solution</h3><p>You can store secrets safely on disk with encryption, decrypt just-in-time to use them normally, and destroy the plaintext.</p><p>Here's a way to do this with PGP that doesn't require you to type a passphrase every time you wish to read the plaintext. With this approach access to the plaintext is controlled by the GnuPG agent and OS login keyring.</p><p><em>This applies to Bourne-compat shells on file-based OSs e.g. BASH and ZSH on MacOS or Linux</em></p><div class="highlight"><pre><span></span><code>❯<span class="w"> </span><span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>gpg<span class="w"> </span>-qd<span class="w"> </span>~/.aws/credentials.gpg<span class="o">)</span>
</code></pre></div><p></p><p>The plaintext of this file is shellcode like...</p><div class="highlight"><pre><span></span><code><span class="nb">export</span><span class="w"> </span><span class="nv">AWS_ACCESS_KEY_ID</span><span class="o">=</span>AKIAJS7UXB9INMRXLOEA
<span class="nb">export</span><span class="w"> </span><span class="nv">AWS_SECRET_ACCESS_KEY</span><span class="o">=</span>vXHZEOVxrBtqMkmadkJv0mCeEglrlFA5oBEywSFw
</code></pre></div><p> ...which makes these values available in the current process environment as well as any child processes' environments. This reduces the surface area for attack by eliminating attack vectors based on filesystem semantics. It is still possible on some operating systems for any process running as <em>you</em> to read the environment variable with which future child processes are invoked, but those processes are likely to be short-lived and will have unpredictable process IDs which are needed to address the process environment directly. Basically, this makes lifting the credential from your computer difficult.</p><h3 id="do-it-yourself">Do it Yourself</h3><p>Composing your own encrypted credentials file requires only free, open-source utilities that run on file-based OSs like Linux, MacOS. I'll assume you are using a Bourne-compat shell e.g. BASH, ZSH. You're on your own for API-based OSs like Windows, but I believe this same approach could work there as well. If you get it working and send me the recipe I'll post it here.</p><p>These steps will allow you to continue using the Default Credential Provider chain in AWS SDKs, boto3/awscli, etc...</p><ul><li>Install and configure GnuPG command-line interface (CLI) for your OS. I'll assume this will also provide the GnuPG agent which is typically included with modern, trusted GPG packages. <a href="http://blog.ghostinthemachines.com/2015/03/01/how-to-use-gpg-command-line/">This blog post</a> looks like a good place to start.</li></ul><p><em>You will need the user ID (UID) e.g. alice@example.com that you choose in this step in a later step.</em></p><ul><li><p>Use GnuPG CLI <code>gpg</code> to create an identity aka PGP private key. Github has <a href="https://help.github.com/articles/generating-a-new-gpg-key/">a helpful post</a> about this.</p></li><li><p>Install the AWS CLI which we'll use to verify these steps work. Amazon covers this <a href="https://aws.amazon.com/cli/">on their web site</a>.</p></li><li><p>If you have more than one credential in <em>~/.aws/credentials</em> then copy each to a separate file with a meaningful name e.g. <em>~/.aws/credentials-example.com</em> and perform the next step for each file.</p></li><li><p>Edit the plaintext file <em>~/.aws/credentials</em> so that it resembles the example above. You can manually insert the <code>export</code> command at the beginning of the two lines and convert the variables names to uppercase or you can run this command which does precisely that in the terminal to prepare the file for encryption.</p></li></ul><div class="highlight"><pre><span></span><code>❯<span class="w"> </span>sed<span class="w"> </span>-E<span class="w"> </span>-e<span class="w"> </span><span class="s1">&#39;/^\[.*\]$/d&#39;</span><span class="w"> </span><span class="se">\</span>
<span class="w">         </span>-e<span class="w"> </span><span class="s1">&#39;s/^(\s+)?(aws_(secret_)?access_key(_id)?)(\s+)?=(\s+)?/export \U\2=\E/g&#39;</span><span class="w"> </span><span class="se">\</span>
<span class="w">         </span>-i<span class="w"> </span>~/.aws/credentials
</code></pre></div><p></p><ul><li>Encrypt the credentials file for your user ID (typically the email address you entered when the PGP identity was generated).</li></ul><div class="highlight"><pre><span></span><code><span class="c1"># this command creates a new file with the same filename as the plaintext + suffix &quot;.gpg&quot;</span>
❯<span class="w"> </span>gpg<span class="w"> </span>-e<span class="w"> </span>-<span class="o">{</span>u,r<span class="o">}</span>alice@example.com<span class="w"> </span>~/.aws/credentials
</code></pre></div><p></p><ul><li>Prove you can decrypt.</li></ul><div class="highlight"><pre><span></span><code>❯<span class="w"> </span>gpg<span class="w"> </span>-qd<span class="w"> </span>&lt;<span class="w"> </span>~/.aws/credentials.gpg
</code></pre></div><p> If this is the first time you have used your PGP identity you may see a GUI popup in your OS prompting for your passphrase. If your OS+GnuPG agent integration allows you may at this time also save the passphrase in your OS keyring. This probably means that your passphrase is chained to your OS login password, and so you should protect that login password with the same measures that are appropriate for your AWS credential.</p><ul><li>Source the plaintext into your shell environment and use the credential to authenticate.</li></ul><div class="highlight"><pre><span></span><code>❯<span class="w"> </span><span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>gpg<span class="w"> </span>-qd<span class="w"> </span>&lt;<span class="w"> </span>~/.aws/credentials.gpg<span class="o">)</span>

❯<span class="w"> </span>aws<span class="w"> </span>iam<span class="w"> </span>get-user
</code></pre></div><p></p><ul><li>If you will be switching between multiple credentials with this method then simply source the plaintext from separate files.</li></ul><div class="highlight"><pre><span></span><code>❯<span class="w"> </span><span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>gpg<span class="w"> </span>-qd<span class="w"> </span>&lt;<span class="w"> </span>~/.aws/credentials-example.com.gpg<span class="o">)</span>
❯<span class="w"> </span><span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>gpg<span class="w"> </span>-qd<span class="w"> </span>&lt;<span class="w"> </span>~/.aws/credentials-example.org.gpg<span class="o">)</span>
</code></pre></div><p></p><ul><li>Now you can delete the plaintext file. If you are feeling less than confident about your future ability to decrypt with your PGP identity then, as a fallback option, consider changing the filemode on the plaintext credentials file so that elevated privileges are required to read it.</li></ul><div class="highlight"><pre><span></span><code>❯<span class="w"> </span>rm<span class="w"> </span>~/.aws/credentials
<span class="c1"># alternatively, make the file unreadable by unprivileged processes</span>
❯<span class="w"> </span>sudo<span class="w"> </span>chown<span class="w"> </span>root<span class="w"> </span>~/.aws/credentials
❯<span class="w"> </span>sudo<span class="w"> </span>chmod<span class="w"> </span><span class="m">0600</span><span class="w"> </span>~/.aws/credentials
</code></pre></div><p></p><h2 id="shortcuts">Shortcuts</h2><h3 id="enable-privileges">Enable Privileges</h3><p>There's no need to memorize the terminal commands. You can save a shellcode "alias" or create a shellcode function to assume any AWS identity for which you have encrypted credentials.</p><p>First, lets look at the most simple case where you have exactly one AWS credential encrypted with the above procedure in <em>~/.aws/credentials.gpg</em>.</p><div class="highlight"><pre><span></span><code><span class="c1"># save the following alias in your aliases dotfile or shell runcom file e.g. ~/.bashrc</span>
<span class="nb">alias</span><span class="w"> </span><span class="nv">onaws</span><span class="o">=</span><span class="s2">&quot;source &lt;(gpg -qd ~/.aws/credentials.gpg)&quot;</span>
</code></pre></div><p></p><div class="highlight"><pre><span></span><code><span class="c1"># alternatively, you could make this default AWS credential available in every new shell</span>
<span class="c1"># environment by including the source command in the shell rc file</span>
<span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>gpg<span class="w"> </span>-qd<span class="w"> </span>~/.aws/credentials.gpg<span class="o">)</span>
</code></pre></div><p></p><div class="highlight"><pre><span></span><code><span class="c1"># source the shell rc file (this happens automatically for your next terminal session)</span>
❯<span class="w"> </span><span class="nb">source</span><span class="w"> </span>~/.bashrc

<span class="c1"># then exec the alias to assume the AWS identity</span>
❯<span class="w"> </span>onaws
</code></pre></div><p></p><p>If instead you have multiple AWS identities you could use a shellcode function and a file naming convention to quickly assume any one identity.</p><div class="highlight"><pre><span></span><code><span class="c1"># save the following function in your aliases dotfile or shell runcom file e.g. ~/.bashrc</span>
onaws<span class="o">(){</span>
<span class="w">  </span><span class="nb">local</span><span class="w"> </span><span class="nv">CREDFILE</span><span class="o">=</span>~/.aws/credentials
<span class="w">  </span><span class="o">[[</span><span class="w"> </span><span class="nv">$#</span><span class="w"> </span>-eq<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">]]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nv">CREDFILE</span><span class="o">=</span><span class="si">${</span><span class="nv">CREDFILE</span><span class="si">}</span>-<span class="si">${</span><span class="nv">1</span><span class="si">}</span>.gpg
<span class="w">  </span><span class="o">}</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nv">CREDFILE</span><span class="o">=</span><span class="si">${</span><span class="nv">CREDFILE</span><span class="si">}</span>.gpg
<span class="w">  </span><span class="o">}</span>
<span class="w">  </span><span class="o">[[</span><span class="w"> </span>-r<span class="w"> </span><span class="nv">$CREDFILE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>-s<span class="w"> </span><span class="nv">$CREDFILE</span><span class="w"> </span><span class="o">]]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nb">source</span><span class="w"> </span>&lt;<span class="o">(</span>gpg<span class="w"> </span>-qd<span class="w"> </span><span class="nv">$CREDFILE</span><span class="o">)</span>
<span class="w">  </span><span class="o">}</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;ERROR: </span><span class="nv">$CREDFILE</span><span class="s2"> is not readable, or is nonexistent or empty; bye.&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p></p><div class="highlight"><pre><span></span><code><span class="c1"># source the shell rc file (this happens automatically for your next terminal session)</span>
❯<span class="w"> </span><span class="nb">source</span><span class="w"> </span>~/.bashrc

<span class="c1"># then exec the function with a positional parameter matching the filename to assume a particular</span>
<span class="c1"># AWS identity e.g. stored in ~/.aws/credentials-example.com.gpg</span>
❯<span class="w"> </span>onaws<span class="w"> </span>example.com
</code></pre></div><p></p><h3 id="disable-privileges">Disable Privileges</h3><p>You may wish to immediately nullify any credentials and session tokens in memory. You're relatively safe if you end the process where the credentials were sourced, but if for some reason it is preferable for that process to continue running you can explicitly unset the variables with a command.</p><div class="highlight"><pre><span></span><code><span class="c1"># save the following alias in your aliases dotfile or shell runcom file e.g. ~/.bashrc</span>
<span class="nb">alias</span><span class="w"> </span><span class="nv">noaws</span><span class="o">=</span><span class="s2">&quot;unset AWS_ACCESS_KEY \</span>
<span class="s2">                   AWS_ACCESS_KEY_ID \</span>
<span class="s2">                   AWS_SECRET_ACCESS_KEY \</span>
<span class="s2">                   AWS_SECURITY_TOKEN \</span>
<span class="s2">                   AWS_SESSION_TOKEN&quot;</span>
</code></pre></div><p></p><div class="highlight"><pre><span></span><code><span class="c1"># source the shell rc file (this happens automatically for your next terminal session)</span>
❯<span class="w"> </span><span class="nb">source</span><span class="w"> </span>~/.bashrc

<span class="c1"># then exec the alias to drop privileges for which ever identity is currently active as well as any</span>
<span class="c1"># Simple Token Service sessions you might have obtained via `assume-role`</span>
❯<span class="w"> </span>noaws
</code></pre></div><p></p><h3 id="assume-role">Assume Role</h3><p>This describes another approach to gaining privileges in AWS and requires that an AWS IAM "role" has already been defined to control access to your resources. This is a global entity in your account that couples an IAM policy to any number of IAM users thereby allowing some action on some resource.</p><p>This is similar but different from using IAM groups to assign the same privileges to multiple users in that it enables granting privileges that span AWS accounts and provides only time-limited, non-interactive session tokens. This is also contrasting to the cumbersome practice of having many IAM user credentials for many AWS accounts.</p><p>It is ideal to grant minimum privileges to a particular role in your own AWS account, and then grant to humans and robots the ability to assume that role with their own IAM user identity. That way they need only one identity regardless of to which AWS account their IAM user belongs, and you can modify the grants for the role in your own AWS account at any time. This also means you never need to know another user's secret access key, and you can still enforce criteria such as multi-factor authentication.</p><p>I've cobbled together <a href="https://github.com/qrkourier/ansible-credstash/blob/master/aws-assume-role.sh">some additional shellcode functions</a> (originally to allow Ansible playbooks to assume an IAM role) that implement the following workflow:</p><ol><li>source an IAM user identity from an encrypted credentials file</li><li>assume a particular IAM role for the maximum allowed session time (one hour)<ul><li>skip assuming role if a session token is already available in a temporary file, and</li><li>prompt for second trust factor (MFA OTP)</li><li>warn if the session token expiry is imminent</li></ul></li><li>drop privileges</li></ol><h2 id="related">Related</h2><p>There are ready-made utilities that also help with properly handling AWS credentials, but that obfuscate the handling of secrets, may place limitations on the way those secrets are used, and are not portable between ubiquitous shell environments. The above solution conserves the trust of yet another piece of software and introduces no limitations to the <code>aws</code> CLI or the default AWS credential discovery chain employed by most other tools. If you're just looking for a convenient remediation for MacOS, then these others below may be a better fit for you.</p><ul><li><p>99Designs has <a href="https://99designs.com/tech-blog/blog/2015/10/26/aws-vault/">a utility called aws-vault</a> for MacOS</p></li><li><p><a href="https://github.com/pda/aws-keychain">aws-keychain</a> for MacOS</p></li></ul><p>AWS publishes <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html">best practices for identity access management</a>.</p><hr></div></article></section><section id="extras" class="body"><div class="social"><h2>social</h2><ul><li><a href="https://www.qrk.us/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li></ul></div></section></body></html>